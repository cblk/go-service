### Go 语言中的异常处理

#### 一、错误和异常的区别
```text
1、错误(Error)
程序中的错误是指发生在程序执行过程中正常的事件，它就在程序正常流程范围之内，代码业务层面可感知、可预期的。
例如打开一个文件时失败，参数不合法 等，这些情况在人们的意料之中。
所以常见的做法就是函数带上一个 error 返回值，惯例是 error 作为返回值的最后一位

2、异常(Exception)
程序中的异常是指发生在程序执行过程中非频繁非正常的事件，它位于程序正常流程之外，是不可预期的。

异常大致可分为两类：
硬件异常：由CPU发起，它们可能是某些指令序列的执行导致的。
软件异常：由应用程序或操作系统显式发起。
例如 下标溢出、除数为0、引用了空指针、 访问非法内存地址 等。

错误和异常可以通过 是否正常、是否可预期、是否终止程序 三个维度来区分：
```
| 概念 | 是否正常 | 是否可预期 | 是否终止程序 |
| :------ | :------: | :------: | :------: |
| 异常 | 否 | 否 | 否/是 |
| 错误 | 是 | 是 | 否/是 |
```text
表中很直观的知道，异常是非正常、不可预期的；错误是正常、可预期的；

是否终止程序：
a、如果在程序Init初始化阶段，发生的错误或异常会影响到后续业务执行的，则需要终止程序；
比如 初始化数据库实例，初始化NoSQL实例，检测配置文件参数不正确 等

b、如果在程序初始化后执行业务阶段，某个业务发生的错误或异常则不能终止程序，其他业务还可以正常使用；
此时发生错误或异常可能需要如下操作：
需要打印不同级别日志、高级别的给予报警处理;
单独的业务最外层需要补获错误和异常; 
根据具体的业务判断是否需要回滚操作, 发通知给第三方相应的事件; 
网络异常情况可多重试几次，超过次数的暂时缓存起来等待组件或第三方可用为止 等。
```

#### 二、Golang 错误和异常处理
```text
error: error接口类型作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含error。
error处理过程的错误码，可逐层返回，直到被处理。
生成error有三种方式: 
errors.New("****"), 示例 base_error.go
fmt.Errorf("****: %+v", err), 示例 base_interface.go
errors.Wrap(err, "****"), 需要第三方包github.com/pkg/errors, 示例 base_wrap.go 
实现 error interface, 示例 base_interface.go 

defer：放在函数里头，一个函数里面可以有多个 defer，按照定义顺序先定义后执行的原则，在函数返回前执行；
panic：函数从调用的地方中断，将 panic 的调用参数入栈，函数准备返回，如果函数有 defer 会先执行 defer；
recover：定义在 defer 函数的第一层（只在第一层生效），当 defer 所在的函数有 panic 时，recover 会返回 panic 的参数，并且消化掉，从而让 defer 所在的函数不会以 panic 的形式返回。

panic 如果不 recover 的话，会一直沿着调用链 panic 上去，直到被捕获或者程序退出；
panic 可以在任何地方引发，但 recover 函数只有在 defer 函数中被直接调用的时候才可以获取 panic 的参数；
如果在 defer 中使用了 recover 函数,则会捕获错误信息，使该错误信息终止报告。
```

#### 三、业务中错误处理规则

##### 1、失败的原因只有一个时，不使用error返回
###### 示例 event_1.go

##### 2、函数处理业务过程中没有错误，不使用error返回
###### 示例 event_1.go

##### 3、当发生错误时，不忽略返回值, 即error要负责任的让调用者知道; 也不要重复处理错误
###### 示例 event_1.go

##### 4、error应放在返回值类型列表的最后
###### 示例 base_error.go 

##### 5、没有失败时，不使用error
###### 示例 event_5.go 

##### 6、错误值统一定义
###### 上层函数要对特定错误value进行统一处理时，以保证错误value统一
###### 示例 event_6.go 

##### 7、对于影响业务继续往下执行的错误，需逐层往外传递; 层层可以日志，也可以最上层统一处理
###### 层层都加日志非常方便故障定位。
###### 示例 event_7.go 
 
##### 8、对于网络或者依赖第三方的服务，在以允许数据最终一致性的情况下，可以尝试几次可以避免失败时立即返回错误
###### 不能无限次数或者for循环的不断调用，考虑递减的时间访问间隔，时间的最大值
###### 示例 event_8.go 

##### 9、协程（coroutine）
###### 协程层 必须接受和处理error，必须处理异常的恢复recover
###### 示例 event_9.go 

#### 三、业务中异常处理规则
```text
Golang引入两个内置函数panic和recover来触发和终止异常处理，同时引入关键字defer来延迟执行defer后面的函数。
不管包含defer语句的函数是通过return的正常结束，还是由于panic导致的异常结束;
函数中会执行defer语句(一条或者多条)，它们的执行顺序与声明顺序相反。
在最上层函数中加一个defer延迟执行的recover调用来捕获异常。

异常执行过程:
当程序运行时，如果遇到引用空指针、下标越界或显式调用panic函数等情况，
则先触发panic函数的执行，然后调用延迟函数。
调用者继续传递panic，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数等。
如果一路在延迟函数中没有recover函数的调用，则会到达该协程的起点，该协程结束，
然后终止其他所有协程，包括主协程（该协程ID为1）。

logy模块会对Error和Fatal的日志打印异常的堆栈，包括调用信息和关键的业务信息，以便查找问题；
找到问题后，将异常转换为错误，以便调用者让程序恢复到健康状态并继续安全运行。
```
###### 示例 event_9.go 

##### 以下情形可以Panic, 让程序异常退出
##### 3.1、功能单元init 初始化，其中含有必要的参数或依赖判断发生的异常
##### 3.2、配置文件读取加载时, 其中含有必要的参数或依赖判断发生的异常
##### 3.3、第三方依赖加载或初始化实例，比如 DB, Redis 等

```text
总结:
1、异常可以发生在程序Init初始化过程
2、错误是业务过程的一部分，而异常不是。
3、对于自己编写的代码逻辑，使用错误返回值，不用人为panic("**")来处理，而是errors.New("**") 返回 。
4、为了防止程序非Init启动过程中可能发生的panic, 在业务处理的最外层使用recover捕获异常进行程序恢复，
并同时进行业务回滚、熔断、降级、关闭业务等处理
5、对程序开发和运行中识别发现的异常panic, 需要进行check，并转化为error 处理
```